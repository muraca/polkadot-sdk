// This file is part of Substrate.

// Copyright (C) Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: Apache-2.0

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::*;
use frame_support::traits::OnRuntimeUpgrade;

#[cfg(feature = "try-runtime")]
use sp_runtime::TryRuntimeError;

use frame_support::{pallet_prelude::*, weights::Weight};

#[derive(Decode)]
pub struct V1AssetDetails<Balance, AccountId, DepositBalance> {
	pub owner: AccountId,
	pub issuer: AccountId,
	pub admin: AccountId,
	pub freezer: AccountId,
	pub supply: Balance,
	pub deposit: DepositBalance,
	pub min_balance: Balance,
	pub is_sufficient: bool,
	pub accounts: u32,
	pub sufficients: u32,
	pub approvals: u32,
	pub status: AssetStatus,
}

impl<Balance, AccountId, DepositBalance> V1AssetDetails<Balance, AccountId, DepositBalance> {
	fn migrate_to_v2(self, inactive: Balance) -> AssetDetails<Balance, AccountId, DepositBalance> {
		AssetDetails {
			owner: self.owner,
			issuer: self.issuer,
			admin: self.admin,
			freezer: self.freezer,
			supply: self.supply,
			inactive,
			deposit: self.deposit,
			min_balance: self.min_balance,
			is_sufficient: self.is_sufficient,
			accounts: self.accounts,
			sufficients: self.sufficients,
			approvals: self.approvals,
			status: self.status,
		}
	}
}

/// This migration moves all the state to v2 of Assets
pub struct VersionUncheckedMigrateToV2<T: Config<I>, I: 'static, A>(
	sp_std::marker::PhantomData<(T, I, A)>,
);

impl<T: Config<I>, I: 'static, A> OnRuntimeUpgrade for VersionUncheckedMigrateToV2<T, I, A> {
	fn on_runtime_upgrade() -> Weight {
		let mut translated = 0u64;
		Asset::<T, I>::translate::<
			V1AssetDetails<T::Balance, T::AccountId, DepositBalanceOf<T, I>>,
			_,
		>(|_asset_id, old_value| {
			translated.saturating_inc();
			let inactive = T::Balance::zero();
			// TODO compute inactives based on input of A
			Some(old_value.migrate_to_v2(inactive))
		});

		T::DbWeight::get().reads_writes(translated, translated)
	}

	#[cfg(feature = "try-runtime")]
	fn pre_upgrade() -> Result<Vec<u8>, TryRuntimeError> {
		log::info!("pre-migration assets v2");
		let prev_count = Asset::<T, I>::iter().count();
		Ok((prev_count as u32).encode())
	}

	#[cfg(feature = "try-runtime")]
	fn post_upgrade(prev_count: Vec<u8>) -> Result<(), TryRuntimeError> {
		log::info!("post-migration assets v2");
		let prev_count: u32 = Decode::decode(&mut prev_count.as_slice())
			.expect("the state parameter should be something that was generated by pre_upgrade");
		let post_count = Asset::<T, I>::iter().count() as u32;
		ensure!(
			prev_count == post_count,
			"the asset count before and after the migration should be the same"
		);
		Ok(())
	}
}

/// [`VersionUncheckedMigrateToV2`] wrapped in a [`frame_support::migrations::VersionedMigration`],
/// ensuring the migration is only performed when on-chain version is 1.
pub type VersionCheckedMigrateToV2<T, I, A> = frame_support::migrations::VersionedMigration<
	1,
	2,
	VersionUncheckedMigrateToV2<T, I, A>,
	crate::pallet::Pallet<T, I>,
	<T as frame_system::Config>::DbWeight,
>;

// This file is part of Substrate.

// Copyright (C) Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: Apache-2.0

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::{Account, Asset, AssetDetails, AssetStatus, Config, DepositBalanceOf, Pallet, Vec};
use frame_support::{
	pallet_prelude::*,
	sp_runtime::traits::{Saturating, Zero},
	traits::OnRuntimeUpgrade,
	weights::Weight,
};

#[cfg(feature = "try-runtime")]
use sp_runtime::TryRuntimeError;

pub mod old {
	use super::*;

	#[frame_support::storage_alias]
	/// Details of an asset.
	pub(crate) type Asset<T: Config<I>, I: 'static> = StorageMap<
		Pallet<T, I>,
		Blake2_128Concat,
		<T as Config<I>>::AssetId,
		AssetDetails<
			<T as Config<I>>::Balance,
			<T as frame_system::Config>::AccountId,
			DepositBalanceOf<T, I>,
		>,
	>;

	#[derive(PartialEq, Eq, Clone, Encode, Decode, RuntimeDebug, TypeInfo)]
	pub(crate) struct AssetDetails<Balance, AccountId, DepositBalance> {
		pub owner: AccountId,
		pub issuer: AccountId,
		pub admin: AccountId,
		pub freezer: AccountId,
		pub supply: Balance,
		pub deposit: DepositBalance,
		pub min_balance: Balance,
		pub is_sufficient: bool,
		pub accounts: u32,
		pub sufficients: u32,
		pub approvals: u32,
		pub status: AssetStatus,
	}

	impl<Balance, AccountId, DepositBalance> AssetDetails<Balance, AccountId, DepositBalance>
	where
		Balance: Zero,
	{
		pub(super) fn migrate_to_v2(
			self,
		) -> super::AssetDetails<Balance, AccountId, DepositBalance> {
			super::AssetDetails {
				owner: self.owner,
				issuer: self.issuer,
				admin: self.admin,
				freezer: self.freezer,
				supply: self.supply,
				inactive: Zero::zero(),
				deposit: self.deposit,
				min_balance: self.min_balance,
				is_sufficient: self.is_sufficient,
				accounts: self.accounts,
				sufficients: self.sufficients,
				approvals: self.approvals,
				status: self.status,
			}
		}
	}
}
/// This migration moves all the state to v2 of Assets
pub struct VersionUncheckedMigrateToV2<
	T: Config<I>,
	I: 'static,
	A: Get<Vec<(T::AssetId, T::AccountId)>>,
>(sp_std::marker::PhantomData<(T, I, A)>);

impl<T: Config<I>, I: 'static, A: Get<Vec<(T::AssetId, T::AccountId)>>> OnRuntimeUpgrade
	for VersionUncheckedMigrateToV2<T, I, A>
{
	fn on_runtime_upgrade() -> Weight {
		let mut translated = 0u64;

		Asset::<T, I>::translate::<
			old::AssetDetails<T::Balance, T::AccountId, DepositBalanceOf<T, I>>,
			_,
		>(|_asset_id, old_value| {
			translated.saturating_inc();
			Some(old_value.migrate_to_v2())
		});

		let mut read = 0u64;
		for (asset_id, account) in A::get() {
			if let Some(acc) = Account::<T, I>::get(&asset_id, &account) {
				Asset::<T, I>::mutate(&asset_id, |asset| {
					if let Some(asset) = asset {
						asset.inactive.saturating_accrue(acc.balance);
					} else {
						log::info!("inactive migration: asset {:?} not found", asset_id);
					}
				});
			} else {
				log::info!(
					"inactive migration: account {:?} not found for asset {:?}",
					account,
					asset_id
				);
			}
			read.saturating_inc();
		}

		T::DbWeight::get().reads_writes(translated + read, translated)
	}

	#[cfg(feature = "try-runtime")]
	fn pre_upgrade() -> Result<Vec<u8>, TryRuntimeError> {
		log::info!("pre-migration assets v2");
		let prev_count = old::Asset::<T, I>::iter().count();
		Ok((prev_count as u32).encode())
	}

	#[cfg(feature = "try-runtime")]
	fn post_upgrade(prev_count: Vec<u8>) -> Result<(), TryRuntimeError> {
		log::info!("post-migration assets v2");
		let prev_count: u32 = Decode::decode(&mut prev_count.as_slice())
			.expect("the state parameter should be something that was generated by pre_upgrade");
		let post_count = Asset::<T, I>::iter().count() as u32;
		ensure!(
			prev_count == post_count,
			"the asset count before and after the migration should be the same"
		);
		Ok(())
	}
}

/// [`VersionUncheckedMigrateToV2`] wrapped in a [`frame_support::migrations::VersionedMigration`],
/// ensuring the migration is only performed when on-chain version is 1.
pub type VersionCheckedMigrateToV2<T, I = (), A = ()> =
	frame_support::migrations::VersionedMigration<
		1,
		2,
		VersionUncheckedMigrateToV2<T, I, A>,
		crate::pallet::Pallet<T, I>,
		<T as frame_system::Config>::DbWeight,
	>;
